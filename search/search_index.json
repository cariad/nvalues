{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NValues introduction NValues is a Python package for working with n -dimensional volumes of data. For example, to create a spreadsheet-like grid of float values with alphabetic x keys and integer y keys: from nvalues import Volume grid = Volume [ tuple [ str , int ], float ]() grid [ \"A\" , 0 ] = 1.2 grid [ \"B\" , 1 ] = 1.4 grid [ \"C\" , 2 ] = 1.6 print ( grid [ \"A\" , 0 ]) # 1.2 See the Volume class for more detail, or if you don't need more than five dimensions then see the Line , Grid , Cube , Tesseract or Penteract wrapper classes for an easier life. Installation NValues requires Python 3.9 or later and can be installed via PyPI : pip install nvalues Support Please raise bugs, feature requests and ask questions at cariad/nvalues/issues . The Project NValues is \u00a9 2022 Cariad Eccleston and released under the MIT License at cariad/nvalues . The Author Hello! \ud83d\udc4b I'm Cariad Eccleston and I'm a freelance backend and infrastructure engineer in the United Kingdom. You can find me at cariad.earth , github/cariad , linkedin/cariad and on Mastodon at @cariad@tech.lgbt .","title":"NValues introduction"},{"location":"#nvalues-introduction","text":"NValues is a Python package for working with n -dimensional volumes of data. For example, to create a spreadsheet-like grid of float values with alphabetic x keys and integer y keys: from nvalues import Volume grid = Volume [ tuple [ str , int ], float ]() grid [ \"A\" , 0 ] = 1.2 grid [ \"B\" , 1 ] = 1.4 grid [ \"C\" , 2 ] = 1.6 print ( grid [ \"A\" , 0 ]) # 1.2 See the Volume class for more detail, or if you don't need more than five dimensions then see the Line , Grid , Cube , Tesseract or Penteract wrapper classes for an easier life.","title":"NValues introduction"},{"location":"#installation","text":"NValues requires Python 3.9 or later and can be installed via PyPI : pip install nvalues","title":"Installation"},{"location":"#support","text":"Please raise bugs, feature requests and ask questions at cariad/nvalues/issues .","title":"Support"},{"location":"#the-project","text":"NValues is \u00a9 2022 Cariad Eccleston and released under the MIT License at cariad/nvalues .","title":"The Project"},{"location":"#the-author","text":"Hello! \ud83d\udc4b I'm Cariad Eccleston and I'm a freelance backend and infrastructure engineer in the United Kingdom. You can find me at cariad.earth , github/cariad , linkedin/cariad and on Mastodon at @cariad@tech.lgbt .","title":"The Author"},{"location":"cube/","text":"Cube class The Cube class is a wrapper around the Volume class to simplify the creation of three-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Cube . Construction Cube requires four generic types: x key type y key type z key type Value type For example, to create a Cube with x string keys, y integer keys, z float keys and boolean values: from nvalues import Cube cube = Cube [ str , int , float , bool ]() Reading, setting and deleting values Values can be read, set and deleted via their keys as described in the base Volume class , but Cube also provides get() , set() and delete() helper functions: from nvalues import Cube cube = Cube [ str , int , float , bool ]( False ) cube . set ( \"A\" , 0 , 1.2 , True ) print ( cube . get ( \"A\" , 0 , 1.2 )) # True cube . delete ( \"A\" , 0 , 1.2 ) print ( cube . get ( \"A\" , 0 , 1.2 )) # False","title":"Cube class"},{"location":"cube/#cube-class","text":"The Cube class is a wrapper around the Volume class to simplify the creation of three-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Cube .","title":"Cube class"},{"location":"cube/#construction","text":"Cube requires four generic types: x key type y key type z key type Value type For example, to create a Cube with x string keys, y integer keys, z float keys and boolean values: from nvalues import Cube cube = Cube [ str , int , float , bool ]()","title":"Construction"},{"location":"cube/#reading-setting-and-deleting-values","text":"Values can be read, set and deleted via their keys as described in the base Volume class , but Cube also provides get() , set() and delete() helper functions: from nvalues import Cube cube = Cube [ str , int , float , bool ]( False ) cube . set ( \"A\" , 0 , 1.2 , True ) print ( cube . get ( \"A\" , 0 , 1.2 )) # True cube . delete ( \"A\" , 0 , 1.2 ) print ( cube . get ( \"A\" , 0 , 1.2 )) # False","title":"Reading, setting and deleting values"},{"location":"grid/","text":"Grid class The Grid class is a wrapper around the Volume class to simplify the creation of two-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Grid . Construction Grid requires three generic types: x key type y key type Value type For example, to create a Grid with x string keys, y integer keys and boolean values: from nvalues import Grid grid = Grid [ str , int , bool ]() Reading, setting and deleting values Values can be read, set and deleted via their keys as described in the base Volume class , but Grid also provides get() , set() and delete() helper functions: from nvalues import Grid grid = Grid [ str , int , bool ]( False ) grid . set ( \"A\" , 0 , True ) print ( grid . get ( \"A\" , 0 )) # True grid . delete ( \"A\" , 0 ) print ( grid . get ( \"A\" , 0 )) # False","title":"Grid class"},{"location":"grid/#grid-class","text":"The Grid class is a wrapper around the Volume class to simplify the creation of two-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Grid .","title":"Grid class"},{"location":"grid/#construction","text":"Grid requires three generic types: x key type y key type Value type For example, to create a Grid with x string keys, y integer keys and boolean values: from nvalues import Grid grid = Grid [ str , int , bool ]()","title":"Construction"},{"location":"grid/#reading-setting-and-deleting-values","text":"Values can be read, set and deleted via their keys as described in the base Volume class , but Grid also provides get() , set() and delete() helper functions: from nvalues import Grid grid = Grid [ str , int , bool ]( False ) grid . set ( \"A\" , 0 , True ) print ( grid . get ( \"A\" , 0 )) # True grid . delete ( \"A\" , 0 ) print ( grid . get ( \"A\" , 0 )) # False","title":"Reading, setting and deleting values"},{"location":"line/","text":"Line class The Line class is a wrapper around the Volume class to simplify the creation of one-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Line . Construction Line requires two generic types: Key type Value type For example, to create a Line with integer keys and string values: from nvalues import Line line = Line [ int , str ]() Reading, setting and deleting values Values can be read, set and deleted via their keys as described in the base Volume class , but Line also provides get() , set() and delete() helper functions: from nvalues import Line line = Line [ int , str ]( \"default\" ) line . set ( 0 , \"zero\" ) print ( line . get ( 0 )) # \"zero\" line . delete ( 0 ) print ( line . get ( 0 )) # \"default\"","title":"Line class"},{"location":"line/#line-class","text":"The Line class is a wrapper around the Volume class to simplify the creation of one-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Line .","title":"Line class"},{"location":"line/#construction","text":"Line requires two generic types: Key type Value type For example, to create a Line with integer keys and string values: from nvalues import Line line = Line [ int , str ]()","title":"Construction"},{"location":"line/#reading-setting-and-deleting-values","text":"Values can be read, set and deleted via their keys as described in the base Volume class , but Line also provides get() , set() and delete() helper functions: from nvalues import Line line = Line [ int , str ]( \"default\" ) line . set ( 0 , \"zero\" ) print ( line . get ( 0 )) # \"zero\" line . delete ( 0 ) print ( line . get ( 0 )) # \"default\"","title":"Reading, setting and deleting values"},{"location":"penteract/","text":"Penteract class The Penteract class is a wrapper around the Volume class to simplify the creation of five-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Penteract . Construction Penteract requires six generic types: v key type w key type x key type y key type z key type Value type For example, to create a Tesseract with v integer keys, w string keys, x string keys, y int keys, z float keys and boolean values: from nvalues import Penteract penteract = Penteract [ int , str , str , int , float , bool ]() Reading, setting and deleting values Values can be read, set and deleted via their keys as described in the base Volume class , but Penteract also provides get() , set() and delete() helper functions: from nvalues import Penteract penteract = Penteract [ int , str , str , int , float , bool ]( False ) penteract . set ( 3 , \"A\" , \"B\" , 0 , 1.2 , True ) print ( penteract . get ( 3 , \"A\" , \"B\" , 0 , 1.2 )) # True penteract . delete ( 3 , \"A\" , \"B\" , 0 , 1.2 ) print ( penteract . get ( 3 , \"A\" , \"B\" , 0 , 1.2 )) # False","title":"Penteract class"},{"location":"penteract/#penteract-class","text":"The Penteract class is a wrapper around the Volume class to simplify the creation of five-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Penteract .","title":"Penteract class"},{"location":"penteract/#construction","text":"Penteract requires six generic types: v key type w key type x key type y key type z key type Value type For example, to create a Tesseract with v integer keys, w string keys, x string keys, y int keys, z float keys and boolean values: from nvalues import Penteract penteract = Penteract [ int , str , str , int , float , bool ]()","title":"Construction"},{"location":"penteract/#reading-setting-and-deleting-values","text":"Values can be read, set and deleted via their keys as described in the base Volume class , but Penteract also provides get() , set() and delete() helper functions: from nvalues import Penteract penteract = Penteract [ int , str , str , int , float , bool ]( False ) penteract . set ( 3 , \"A\" , \"B\" , 0 , 1.2 , True ) print ( penteract . get ( 3 , \"A\" , \"B\" , 0 , 1.2 )) # True penteract . delete ( 3 , \"A\" , \"B\" , 0 , 1.2 ) print ( penteract . get ( 3 , \"A\" , \"B\" , 0 , 1.2 )) # False","title":"Reading, setting and deleting values"},{"location":"tesseract/","text":"Tesseract class The Tesseract class is a wrapper around the Volume class to simplify the creation of four-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Tesseract . Construction Tesseract requires five generic types: w key type x key type y key type z key type Value type For example, to create a Tesseract with w string keys, x string keys, y int keys, z float keys and boolean values: from nvalues import Tesseract tesseract = Tesseract [ str , str , int , float , bool ]() Reading, setting and deleting values Values can be read, set and deleted via their keys as described in the base Volume class , but Tesseract also provides get() , set() and delete() helper functions: from nvalues import Tesseract tesseract = Tesseract [ str , str , int , float , bool ]( False ) tesseract . set ( \"A\" , \"B\" , 0 , 1.2 , True ) print ( tesseract . get ( \"A\" , \"B\" , 0 , 1.2 )) # True tesseract . delete ( \"A\" , \"B\" , 0 , 1.2 ) print ( tesseract . get ( \"A\" , \"B\" , 0 , 1.2 )) # False","title":"Tesseract class"},{"location":"tesseract/#tesseract-class","text":"The Tesseract class is a wrapper around the Volume class to simplify the creation of four-dimensional volumes. All the base functionality, such as default values, key accessors and iteration, is inherited by Tesseract .","title":"Tesseract class"},{"location":"tesseract/#construction","text":"Tesseract requires five generic types: w key type x key type y key type z key type Value type For example, to create a Tesseract with w string keys, x string keys, y int keys, z float keys and boolean values: from nvalues import Tesseract tesseract = Tesseract [ str , str , int , float , bool ]()","title":"Construction"},{"location":"tesseract/#reading-setting-and-deleting-values","text":"Values can be read, set and deleted via their keys as described in the base Volume class , but Tesseract also provides get() , set() and delete() helper functions: from nvalues import Tesseract tesseract = Tesseract [ str , str , int , float , bool ]( False ) tesseract . set ( \"A\" , \"B\" , 0 , 1.2 , True ) print ( tesseract . get ( \"A\" , \"B\" , 0 , 1.2 )) # True tesseract . delete ( \"A\" , \"B\" , 0 , 1.2 ) print ( tesseract . get ( \"A\" , \"B\" , 0 , 1.2 )) # False","title":"Reading, setting and deleting values"},{"location":"volume/","text":"Volume class The Volume class represents a strongly-typed n -dimensional volume of values. Construction Volume requires two generic types: Tuple of key types Value type For example: from nvalues import Volume # A dictionary with integer keys and string values: volume = Volume [ tuple [ int ], str ]() # A grid with integer coordinates and string values: volume = Volume [ tuple [ int , int ], str ]() # A spreadsheet of floats with horizontal alphabetic keys and # vertical integer keys: volume = Volume [ tuple [ str , int ], float ]() # A cube of booleans with integer x, string y and float z keys: volume = Volume [ tuple [ int , str , float ], bool ]() Default values By default, volumes will raise nvalues.exceptions.NKeyError if you try to read a key that doesn't exist. To return a default value instead, you can either: Pass the default value as the default argument: from nvalues import Volume volume = Volume [ tuple [ int , int ], str ]( default = \"default\" ) print ( volume [ 0 , 0 ]) # \"default\" Pass a function that generates a default value as the default_maker argument: from nvalues import Volume def make_default ( key : tuple [ int , int ]) -> str : return f \"default for { key } \" volume = Volume [ tuple [ int , int ], str ]( default_maker = make_default ) print ( volume [ 0 , 0 ]) # \"default for (0, 0)\" Default values generated at runtime will be added to the volume, while static defaults will not. Reading, setting and deleting values Values are read, set and deleted via their keys. For example: from nvalues import Volume volume = Volume [ tuple [ str , int ], float ]( default = 0 ) volume [ \"A\" , 0 ] = 1.2 print ( volume [ \"A\" , 0 ]) # 1.2 del volume [ \"A\" , 0 ] print ( volume [ \"A\" , 0 ]) # 0 Key validation A Volume can be configured to reject invalid keys if a validator is passed in the initialiser or set on the key_validator property. If set, the key validator is a function that examines the key and raises any exception if it's invalid. Any attempts to access an invalid key will result in InvalidKey being raised. from nvalues import Volume from nvalues.exceptions import InvalidKey max_x = 3 max_y = 4 def check_key_range ( key : tuple [ int , int ]) -> None : x = key [ 0 ] if x < 0 or x > max_x : raise ValueError ( f \"x { x } must be 0- { max_x } inclusive\" ) y = key [ 1 ] if y < 0 or y > max_y : raise ValueError ( f \"y { y } must be 0- { max_y } inclusive\" ) volume = Volume [ tuple [ int , int ], str ]( key_validator = check_key_range ) try : volume [ 0 , 17 ] = \"foo\" except InvalidKey as ex : print ( ex ) # Key (0, 17) failed validation (y 17 must be 0-4 inclusive) Iterating values Volume natively supports iteration and will yield the key and value for every item it holds. from nvalues import Volume volume = Volume [ tuple [ int , int ], str ]() volume [ 0 , 0 ] = \"zero-zero\" volume [ 4 , 0 ] = \"four-zero\" volume [ 0 , 4 ] = \"zero-four\" for item in volume : print ( f \"Found { item . value } at { item . key } \" ) # Found zero-zero at (0, 0) # Found zero-four at (0, 4) # Found four-zero at (4, 0)","title":"Volume class"},{"location":"volume/#volume-class","text":"The Volume class represents a strongly-typed n -dimensional volume of values.","title":"Volume class"},{"location":"volume/#construction","text":"Volume requires two generic types: Tuple of key types Value type For example: from nvalues import Volume # A dictionary with integer keys and string values: volume = Volume [ tuple [ int ], str ]() # A grid with integer coordinates and string values: volume = Volume [ tuple [ int , int ], str ]() # A spreadsheet of floats with horizontal alphabetic keys and # vertical integer keys: volume = Volume [ tuple [ str , int ], float ]() # A cube of booleans with integer x, string y and float z keys: volume = Volume [ tuple [ int , str , float ], bool ]()","title":"Construction"},{"location":"volume/#default-values","text":"By default, volumes will raise nvalues.exceptions.NKeyError if you try to read a key that doesn't exist. To return a default value instead, you can either: Pass the default value as the default argument: from nvalues import Volume volume = Volume [ tuple [ int , int ], str ]( default = \"default\" ) print ( volume [ 0 , 0 ]) # \"default\" Pass a function that generates a default value as the default_maker argument: from nvalues import Volume def make_default ( key : tuple [ int , int ]) -> str : return f \"default for { key } \" volume = Volume [ tuple [ int , int ], str ]( default_maker = make_default ) print ( volume [ 0 , 0 ]) # \"default for (0, 0)\" Default values generated at runtime will be added to the volume, while static defaults will not.","title":"Default values"},{"location":"volume/#reading-setting-and-deleting-values","text":"Values are read, set and deleted via their keys. For example: from nvalues import Volume volume = Volume [ tuple [ str , int ], float ]( default = 0 ) volume [ \"A\" , 0 ] = 1.2 print ( volume [ \"A\" , 0 ]) # 1.2 del volume [ \"A\" , 0 ] print ( volume [ \"A\" , 0 ]) # 0","title":"Reading, setting and deleting values"},{"location":"volume/#key-validation","text":"A Volume can be configured to reject invalid keys if a validator is passed in the initialiser or set on the key_validator property. If set, the key validator is a function that examines the key and raises any exception if it's invalid. Any attempts to access an invalid key will result in InvalidKey being raised. from nvalues import Volume from nvalues.exceptions import InvalidKey max_x = 3 max_y = 4 def check_key_range ( key : tuple [ int , int ]) -> None : x = key [ 0 ] if x < 0 or x > max_x : raise ValueError ( f \"x { x } must be 0- { max_x } inclusive\" ) y = key [ 1 ] if y < 0 or y > max_y : raise ValueError ( f \"y { y } must be 0- { max_y } inclusive\" ) volume = Volume [ tuple [ int , int ], str ]( key_validator = check_key_range ) try : volume [ 0 , 17 ] = \"foo\" except InvalidKey as ex : print ( ex ) # Key (0, 17) failed validation (y 17 must be 0-4 inclusive)","title":"Key validation"},{"location":"volume/#iterating-values","text":"Volume natively supports iteration and will yield the key and value for every item it holds. from nvalues import Volume volume = Volume [ tuple [ int , int ], str ]() volume [ 0 , 0 ] = \"zero-zero\" volume [ 4 , 0 ] = \"four-zero\" volume [ 0 , 4 ] = \"zero-four\" for item in volume : print ( f \"Found { item . value } at { item . key } \" ) # Found zero-zero at (0, 0) # Found zero-four at (0, 4) # Found four-zero at (4, 0)","title":"Iterating values"}]}